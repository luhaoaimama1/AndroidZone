【0】优先队列(数组构成) (允许重复元素)
    找到最大的元素 /最小元素
    定义： 当一颗二叉树的每个节点都大于等于它的子节点时，它被称为有序堆

 * 二叉树 ：那么就是N个数能除多少次2
 * 就是Log2,N 对数N不应该含有为0 , 那么a[0]站位。 而且他站位的好处是 k的上一个节点是k/2
 * 那么 层数=floor(Log2,N)
 * 某个节点k
 * 上一个节点的在数组的坐标就是k/2
 * 子节点在数组的 2k,2k+1
 * 实现主要是 上浮和下沉，
 * 添加[在数组最后添加元素，然后上浮该位置]，取出最大【删除最大的元素，吧最后的元素放到最上面，然后下沉】

【1】Heap 堆排序。
就是优先队列的应用。
先变成堆有序
(1) 简单的就是 挨个添加 上浮 但是他对最后一排也会操作
(2) 从倒数第二层 开始 对上面所有的元素 以此做下沉造作，那么最后变成有序堆 根据优先队列的定义就可知道。
那么相对于(1) 少操作了最后一层。
然后取出最大,知道取没了

【3】 二叉树查找树(节点构成)(允许重复元素)
    定义： 一颗二叉树查找树十一二二叉树，其中每个结点都含有一个Compable的键以及关联的值，
且每个结点的键都大于其左子树的任意结点的键而小于右子树的任意结点的键
需要知道一个结论： 有序二叉树 投影 到直线上就是一个有序的序列。（原理就是定义）

添加 获取 操作相对简单
删除： 需要明白删除最小的方式， 正常的删除某个节点。要考虑 那个节点 是否包含两个子节点。如果不是那么子节点替换这个就好了
如果是的话就需要右侧最小的节点来替换。

//todo 把所有的都整理下  不然都忘记了 忘记的太快了